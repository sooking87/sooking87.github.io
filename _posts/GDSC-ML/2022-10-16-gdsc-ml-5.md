---
title: "[week 3] CNN의 이해 (3)"
excerpt: "[week 3] CNN의 이해 (3)"
categories: [GDSC ML]
tags: [GDSC ML, Python]
toc: true
toc_sticky: true
---

## CNN

### A bit of history

### CNN

경계를 잘 분류한다. 그 이상의 구체적인 분류도 가능하다. 그 경계 상자만 찾는 것이 아니라 모든 픽셀에 대한 레이블을 지정할 수도 있다. <br>

얼굴 인식 가능, 포즈 인식 가능, 게임에서의 강화 학습에 사용된다. 의료 이미지의 해석 및 진단, 은하 분류, 거리 표지판 분류, 고래 인삭(Kaggle Challenage), 거리 분류, 사진을 찍고 특정 화가의 이미지로 다시 이미지화(Redraw)에도 사용된다.

<img width="1000" alt="download1" src="https://user-images.githubusercontent.com/96654391/196013892-2900e1b9-c83f-4c25-8ce4-f1c31841c3c6.png">

## How CNN Works

### Fully Connected Layer

<img width="1000" alt="download2" src="https://user-images.githubusercontent.com/96654391/196013893-d81f00f2-eb16-4eda-b793-139d1c9c9220.png"> <br>

만약에 32 \* 32 \* 3 이미지가 들어왔을 때, 이를 3072차원의 벡터로 변경시킨다.이미지들의 픽셀들을 다 일렬로 나열시킨다고 볼 수 있을듯? 강의에서는 strectch to 3072 \* 1이라고 표현. 그렇게 된다면 1 \* (32 \* 32 \* 3)의 값이 될 것이다. 3072차원의 벡터로 변경시킨다. <br>

-> 10개의 가중치가 있다고 한다면 input(1 \* 3072) \* Weight(3072 \* 10) (내적 곱을 통해서 구함) <br>

-> activation(output of this layers)(1 \* 10) 뉴런 output은 10개를 가지게 될 것이다. <br>

### Convolution Layer

Fully Connected Layer와의 차이점은 Fully Connected 의 경우 3차원으로 입력을 받아도 결국 하나의 긴 벡터로 펼친 후에 사용을 했는데, Convolution의 경우는 3차원 입력값을 그대로 사용한다.

<img width="1000" alt="download1" src="https://user-images.githubusercontent.com/96654391/196018454-580dd987-0892-47aa-b299-338b9c8a45fa.png">

필터의 너비와 높이의 크기는 입력보다 작을지라도 높이는 동일해야됩니다. 이 필터는 가중치가 된다. <br>

<img width="1000" alt="download2" src="https://user-images.githubusercontent.com/96654391/196018456-fe66b36f-f05a-4de7-8e9d-783ead79fb35.png">

이 필터를 가지고 처음부터 stride만큼 이동을 하면서 이미지의 공간 위치 위에 오버레이를 한 다음 내적을 계산한다. 필터와 이미지의 작은 5\*5\*3의 작은 청크 사이의 내적 곱이 필터와 이미지 청크를 펼쳐서 계산한 값과 같다.

<img width="1000" alt="download1" src="https://user-images.githubusercontent.com/96654391/196019013-60cbb975-7ba0-4f3b-9494-22a006a142de.png">

이렇게 계산된 하나의 값이 있는데, 필터를 한 칸씩 이동을 하면서 해당 이미지 청크와 합성곱을 구하고, 이렇게 해서 activation map이 생기게 된다.

<img width="1000" alt="download2" src="https://user-images.githubusercontent.com/96654391/196019018-4b240f9b-7f44-4395-859b-823d2fd5aba4.png">

<img width="1000" alt="download1" src="https://user-images.githubusercontent.com/96654391/196019102-a6f136c4-43b4-4c82-8ed7-84fa74a903c2.png">

필터를 다르게 해서(색깔이 다른 것을 통해서 확인할 수 있다.) 여러 개의 activation maps가 생긴것을 확인할 수 있다. <br>

결론적으로 28 _ 28 _ 6인 새로운 이미지를 쌓은 것을 확인할 수 있다.

<img width="1000" alt="download2" src="https://user-images.githubusercontent.com/96654391/196019191-6fe25e9f-f87c-4d0f-937a-73e7bbffc51e.png">

최종적으로 ConvNet은 Convolution Layers의 연속으로 이루어져 있는데 중간중간 렐루를 가지고 있는 것을 확인할 수 있다. <br>

렐루 함수란 시그모이드처럼 활성화함수긴 하지만 시그모이드의 경우는 0~1로 값을 바꾸어주지만 이는 시간이 너무 오래 걸리기 때문에 이미지 처리에는 주로 렐루 함수를 사용한다고 합니다. 렐루 함수는 음수인 경우는 0으로, 양수인 경우는 그냥 똑같은 값으로 출력을 해주는 함수입니다.

### Stride

- stride = 1
  <img width="500" alt="download1" src="https://user-images.githubusercontent.com/96654391/196019387-084ee17a-36e6-429e-a8f7-ae14a498642d.png">

    <img width="500" alt="download2" src="https://user-images.githubusercontent.com/96654391/196019388-5fcc8ed3-62ee-440d-b86f-d2c874dc8605.png">

    <img width="500" alt="download1" src="https://user-images.githubusercontent.com/96654391/196019411-d8be6395-2cf6-4492-916d-baabf196c994.png">

    <img width="500" alt="download2" src="https://user-images.githubusercontent.com/96654391/196019412-d0d910d3-9532-4d22-a058-ab6211313075.png">

    <img width="500" alt="download1" src="https://user-images.githubusercontent.com/96654391/196019431-096467fa-7a0c-499b-ba10-18793839cfb1.png">

- stride = 2

    <img width="500" alt="download1" src="https://user-images.githubusercontent.com/96654391/196019476-9422f394-c20e-4bea-bb7e-d58a7cbc70f1.png">

    <img width="500" alt="download2" src="https://user-images.githubusercontent.com/96654391/196019479-d42763f8-7fd8-4b42-b698-485bd1439595.png">
    
    <img width="500" alt="download3" src="https://user-images.githubusercontent.com/96654391/196019480-fc8006a0-5155-4b8d-8bc8-9366364c87d9.png">

- stride = 3

  딱 맞아떨어지지 않으므로 3 \* 3필터를 적용할 수 없다. <br>

Output Size = (이미지의 가로/세로 - 필터의 가로/세로) / stride + 1

### Padding

<img width="500" alt="download1" src="https://user-images.githubusercontent.com/96654391/196019636-c51a4933-e35f-4920-82cc-577ac06c34be.png">

일반적으로 가운데 원본 이미지 픽셀 주변에 0으로 채우는 것을 패딩이라고 한다. 필터를 사용할 때마다 이미지의 크기는 점점 작아지게 된다. 하지만 우리는 이미지의 원래 크기를 보존하고 싶어하기 때문에 이미지 크기가 줄어드는 것을 막기 위해서 주변에 패딩을 넣어줍니다.

### Pooling Layer

<img width="1000" alt="download1" src="https://user-images.githubusercontent.com/96654391/196019911-ba35bfc6-b938-4b44-ad3d-10ba17f672b6.png">

Max Pooling의 경우는 필터의 크기 안에서 값이 가장 큰 값을 가져오는 형식으로 진행이 된다. <br>

<br>

풀링층을 만드는 이유는 층의 크기를 작고 다루기 쉽게 만들기 위해서 입니다. 강의 질문중에 stride를 수정해서 겹치게 할 수는 없냐는 질문이 있었는데, 일반적으로는 겹치지 않게 stride를 설정하는 것이 일반적이라고 했다. 애초에 풀링을 한다는 의미는 downsampling을 하는 것이기 때문이다. <br>

다른 질문으로는 왜 Avg Pooling 보다 Max Pooling을 더 자주 사용하냐는 질문이었다. 그 이유는 우리가 풀링을 통해서 다운샘플링 분만이 아니라 나타나려는 것을 확실히 알 수 있는 것에도 도움을 받기 때문에 굳이 평균보다는 Max값을 사용하는 것이 확실한 특징을 얻을 수 있다고 했다.

### Conv Layers Summarize

<img width="1000" alt="download1" src="https://user-images.githubusercontent.com/96654391/196020085-b2f382d6-1b72-43a8-bfa3-836aa8a37f65.png">
