---
title: "1.2주차"
excerpt: "1.2주차"
categories: [Cpp Programming]
tags: [Cpp Programming, Cpp]
toc: true
toc_sticky: true
---

## The Aims

- Cpp 문법
- OOP, Structual Programming 개념 및 활용한 문제 풀이

## Why C++?

C/C++의 경우는 효율성이 굉장히 높다. <br>

현재 무어의 법칙에 의해서 HW는 엄청난 속도로 발전을 했다. 그러면 SW 역시 이에 맞는 속도로 발전을 해야 HW를 활용할 수 있다. <br>

하지만 SW의 경우는 발전이 느려 => 왜? HW는 표준화를 할 수 있어서 누적을 통해서 엄청난 속도로 발전이 가능하다. 하지만 SW의 경우 소스코드의 보안이 높아서 발전이 제한적이다. 결국 과걱에는 하나의 새로운 프로그램을 짜기 위해서는 모든 기능을 처음부터 구현해야되는 문제가 발생하였다. <br>

이렇게 되면서 SW의 생산성은 급격히 떨어졌고 결국 소스 코드들을 재사용하기 위해서 OOP의 개념이 도입되었다. <br>

OOP의 도입으로 인해서 기본 소스코드에 바뀌는 부분만 Overwrite를 통해서 생산성을 높이고자 하였다. 여기서 C 언어에서 OOP의 개념을 적극 반영한 언어가 C++인것이다. <br>

<C++언어가 Major가 아닌 이유 1.> <br>

하지만 C++이 지금 현재 가장 많이 사용되지 않는 이유는 자바, 파이썬으로 인해서 오픈소스 붐이 있었다. 하지만 OOP는 **오픈 소스 없이** 재사용을 극대화하였다. 하지만 오픈소스가 더 많이 사용되므로 과거보다 OOP의 중요성이 줄어든 것은 맞는 것이다. <br>
<br>

<C++언어가 Major가 아닌 이유 2.> <br>

C/C++은 Machine Dependancy가 최고,,, -> 이게 좋은 말일까? 기계 의존성이 높다는 것은 HW마다 사용하는 기계어가 달라서 다른 HW마다 다른 소스코드를 필요하다는 말이다. 소스 코드들을 공유하기 어렵다. 즉, 내 노트북에서는 돌아갔는데 다른 노트북에서는 돌아가지 않을 가능성이 높다는 것이다. 그 소스코드가 나랑 같은 HW인 경우는 코드가 실행이 되지만 다른 경우는 돌아가지 않는다. 이를 없애고자 JAVA가 등장한 것이다. <br>

JAVA의 경우는 JVM이라는 가상 머신을 사용한다. JAVA -> 컴파일러 -> 바이트코드 -> 인터프리터 -> 기계어 -> Real Machine 순으로 진행이 된다. 그래서 Java의 경우는 컴파일러, 인터프리터를 거치기 때문에 느리다. 하지만 Java + 인터넷으로 인해서 소스코드 공유가 쉬워서 뜨게 된 언어이다. 파이썬은 인터프리터 Language이다. 런타임은 컴파일러가 가장 빠르다. 그렇기 때문에 파이썬은 런타임이 오래걸린다. 하지만 많은 라이브러리와 개발 생산성이 좋다. 오픈소스로 기하 급수적으로 라이브러리가 생겼기 때문이다. <br>

> 그럼에도 효율성을 강조하는 영역에서는 C/C++이 최강! <br>

위에서 C/C++은 Machine Dependancy로 소스 코드가 공유하기 어렵다고 했는데, 그래도 이를 줄이고자 최소한의 표준( _ISO standard_ )이 있긴 하다. 그래도 모든 범위를 커버하는 것은 사실이다.

## Why Programming?

왜 프로그래밍이 중요해지고 있을까? <br>

- 1차 산업혁명: physical 영역에서의 기계화 -> 증기기관 <br>
  증기기관이 physical한 영역을 기계화 시켰다. 예를 들어서 말, 마차 등 다 생물에 의존해서 이동하던 수단이 기관차로 바뀌게 되었다. 또한 사람이 직접 물레를 돌려서 만들었던 섬유사업 역시 증기기관을 통해서 기계가 대신하게 되었다. 이로 인해서 물리적 영역에서의 생산량이 증가하게 되었다.

- 2차 산업혁명: 전기의 발명 <br>
  증기 -> 전기로 바뀌게 되었다. 증기의 경우는 다루기 어렵지만 증기의 운동 E를 전기로 바꾸어서 사용하면 디테일하게 컨트롤이 가능하다. 같은 physical 영역이더라도 정확도가 높아졌다. 예를 들어서 워크맨,, -> 얘를 증기로 만들 수 있을까? 너무 커서 주머니에 못 넣고 다닐 것이다. -> 이로써 2차 산업혁명은 전기의 도입으로 인해서 물리적 영역에서의 세부적 생산성까지 올라갈 수 있었다.

- 3차 산업혁명: 컴 + 통신(인터넷) 즉 logical 영역에서의 기계화까지 들어가기 시작했다. <br>
  논리적 영역이란 기억하고, 정리하는 것을 얘기하는 것 같다. 이제는 인터넷에 기록을 하고 Memory가 그 기록을 기억하는 형식이다. 과거에는 논리적 영역은 사람만 할 수 있는 영역, 말, 소에게는 맡길 수 없는 일을 얘기했다. 이런거를 기계가 대체하는 것이 3차 산업혁명이다.

- 4차 산업혁명: 더 지능적으로 논리적 영역에 대한 기계의 접근이 필요하다. <br>
  그리고 이들을 다루기 위해서는 프로그래밍이 핵심 툴이므로 프로그래밍을 배우는 것이다.

## A first Program

- Structual Program: 절차적 프로그래밍으로 goto를 사용하지 않는 것을 말한다. 즉, 코드를 적은 순서대로만 진행하는 구조를 가지고 있다. 명령어들의 1차원적 집합 및 수행,,, <br>
  문: 프로그래밍이 수행해야되는 명령어 숫자가 많다. (반복적으로 사용되는 명령어들도 많다.) <br>

  가장 쉬운 해결책: 코드의 재사용을 하면 된다. 복붙 or Jump 명령어 사용

- Functional Program: 함수형 프로그래밍으로 Jump 명령어는 C/C++에서의 goto와 같다. 근데 이를 남발하게 되면 코드상에 맥락이 없다. 결국 스파게티 코드가 되고 코드의 가독성도 없어지게 된다. 그래서 structual에서 goto를 쓰는 대신 Function을 사용해서 중첩구조가 확실하고 flow가 보이도록하여 가독성을 높였다.

## Compilation and Linking

> C++ source code -> C++ Compiler -> object code + Library Object Code -> linker -> Excute <br>

- C++ Compiler: 통으로 번역, High Lang -> Low Lang으로 번역을 한다. 번역에 있어서 문법은 중요하다. 그래서 컴파일러는 문법을 체크하는 일을 한다. 맞지 않는다면 번역이 안되기 때문이다. 검사하는 문법은 크게 두가지 이다.

  - user defined 문법: 변수명, 함수명 -> 선언 여부로 확인한다. 변수 선언은 데이터형을 컴파일러에게 알려주는 것을 말한다. 함수 선언의 경우는 `int myFunc(int, int);` 와 같은 경우가 있다. 그리고 컴파일러는 변수 및 함수의 매개변수, 리턴값이 이 데이터형과 맞게 쓰이는지를 확인하고 다 통과를 하게되면 그제서야 번역을 한다.
  - hard code 문법: if(){} else{} 이런 원래 근본 문법 검사 <br>
    <br>

  컴파일러는 번역단계에서 모든 변수를 주소와 연결하지 않는다. 주소는 오로지 definition이 있는 경우만 확실히 부여하게 된다. 그 외의 변수는 ?로 바꾸고 linker에게 넘김

- Linker: 컴파일러가 ? 로 넘긴 애들을 모든 파일들을 뒤져서 값을 채워준다.
