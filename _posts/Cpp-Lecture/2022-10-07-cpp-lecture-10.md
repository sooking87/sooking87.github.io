---
title: "6.1주차"
excerpt: "6.1주차"
categories: [Cpp Programming]
tags: [Cpp Programming, Cpp]
toc: true
toc_sticky: true
---

## 실습 13

두 점이 입력되면 몇 사분면에 해당하는지 구하는 문제. 입력값에 0은 없다.

## 내가 제출한 코드

넘 쉬워성,, vscode에서 풀지도 않음,, ㅎ

## 실습 14

조합을 구하는 문제이다. 여기서 문제는 OverFlow 문제,,, 아무도 해결 못함,,, <br>

근데 여튼 여기서 배운 점은 예외 처리 하는 방법이다.

## 실습 14를 활용한 예외 처리 방법

기본 코드

```cpp
#include <iostream>
#include <iostream>
#include <string>
#include <vector>

using namespace std;

int product(int from, int count)
{
    int answer = 1;
    int temp;
    for (int i = 0; i < count; i++)
    {
        temp = answer * (from - i);
        answer = temp;
    }

    return answer;
}
int solution(int balls, int share)
{
    int answer;

    int a = product(balls, share);
    int b = product(share, share);
    answer = a / b;

    cout << "answer: " << answer << endl;
    return answer;
}
int main()
{
    int balls, share;
    cin >> balls >> share;
    cout << solution(balls, share);
}
```

product() 함수를 통해서 from 부터 1씩 작아지면서 count 만큼 곱해진 값이 나온다. 예를 들어서 5C3인 경우 product(5, 3)인 경우는 5 _ 4 _ 3이고 product(3, 3)인 경우는 3 _ 2 _ 1 의 결과값을 나오게 한다. 여튼 이렇게 하면 조합의 값을 구할 수 있는데, 계속 overflow 에러가 발생했다. <br>

예외 가능성 <br>

1. 입력값이 음수인 경우 -> incorrectInput()
2. balls보다 share의 개수가 많은 경우 -> incorrectInput()
3. overflow가 발생한 경우 -> 곱해지기 전보다 곱해진 후의 값이 크다면 overflow로 평가. <br>

클래스를 아직 모르는 입장에서 예외처리는 어케 하냐?

step 1.

```cpp
class incorrectInput
{
};
class overflowError
{
};
```

처리하고 싶은 에러의 이름을 가지고 있는 클래스를 만든다. <br>

<br>

step 2.

```cpp
for (int i = 0; i < count; i++)
{
    temp = answer * (from - i);
    if (temp < answer)
        throw overflowError();
    answer = temp;
}
```

코드를 실행하다가 내가 처리하고 싶은 에러가 있다면 그 부분에서 throw를 통해서 에러를 던져준다.

step 3.

```cpp
try
{
    int a = product(balls, share);
    int b = product(share, share);
    answer = a / b;
}
catch (overflowError e)
{
    cout << "OverFlow Error" << endl;
}
catch (incorrectInput e)
{
    cout << "OverFlow Error from solution" << endl;
}
```

throw가 발생하는 순간 돌고 있던 그 함수에서는 나오고 바깥 함수로 나오게 된다. 여기서 throw된 에러와 같은 에러는 catch 하고 있다면 여기서 catch안에 있는 코드로 적절한 조치를 취해준 후, 다음 코드로 **정상 진행** 이 된다.

```cpp
#include <iostream>
#include <iostream>
#include <string>
#include <vector>

using namespace std;

class incorrectInput
{
};
class overflowError
{
};

int product(int from, int count)
{
    int answer = 1;
    int temp;
    for (int i = 0; i < count; i++)
    {
        temp = answer * (from - i);
        if (temp < answer)
            throw overflowError();
        answer = temp;
    }

    return answer;
}
int solution(int balls, int share)
{
    int answer;
    if (balls <= 0 || share <= 0)
        throw incorrectInput();

    try
    {
        int a = product(balls, share);
        int b = product(share, share);
        answer = a / b;
    }
    catch (overflowError e)
    {
        cout << "OverFlow Error" << endl;
    }
    catch (incorrectInput e)
    {
        cout << "OverFlow Error from solution" << endl;
    }

    cout << "answer: " << answer << endl;
    return answer;
}
int main()
{
    int balls, share;
    cin >> balls >> share;
    try
    {
        cout << solution(balls, share);
    }
    catch (incorrectInput e)
    {
        cout << "Incorrect Error from Main" << endl;
    }
}
```

### 예외 처리 구체적인 진행 과정

예외 처리: 문제를 미리 예상 조건을 비교해서 적절한 exception을 던지는게 첫 번째 목표 = 지금 무슨 문제 때문에 발생했는지 알려주고 싶어 => 그래서 에러 명을 따로 클래스로 만들어준 것이다. 클래스를 통해서 누가 throw 한 에러인지를 판단한다. <br>

예를 들어서 product에서 throw가 발생한다면 그 순간 바로 그 함수에서 exit을 해버린다. 즉, throw 가 있는 그 함수에서의 모든 코드는 바로 무시가 된다. 그러면서 실행했던 product는 바로 종료되면서 그 함수에서는 incorrectInput이라는 객체만 날라가게 된다. product 함수가 정상 종료가 되지 않았기 때문에 product 바깥 함수인 solution 역시 그 아래 코드들이 모두 무시된다. 즉, try & catch가 없다면 모든 함수로부터 무서운 속도로 빠져나와 exception object를 던지게 된다. 그렇다면 여기서 이 객체를 멈추게 하고 싶다면 try & catch를 이용하면 된다. try 라고 되어 있는 코드 안에는 발생할 수 있는 exception을 throw할 수 있는 코드가 있다. 만약 try에서 예외 객체가 날라온다면 catch를 통해서 잡아줄 수 있다. 여기서 catch는 모든 예외들을 잡는 것이 아니라 특정 예외만 잡을 수 있다. 여튼 catch에 예외가 들어온다면 catch안에 코드를 통해서 적절한 조치 후 정상 종료를 가능하게 한다. <br>

가장 바람직한 시나리오는 적절한 예외를 깨닫고, 이에 따른 적절한 예외를 처리하는 것이다. 이로써 정상 운영/진행이 목적이기 때문에 따라서 throw를 던지는 순간 무조건 프로그램 종료가 되지만 이를 catch를 통해서 어떤 예외가 발생했으며, 프로그램 종료를 막고, 정상적인 상황 처리를 해줌으로서 정상 종료가 되도록 해준다. <br>

try에서 날라오는 exception을 catch가 잡아준다. 문제는 catch가 골라잡는다는 것이다. solution에서의 첫 번째 catch는 overflorError 에러만 잡고, 두 번째 catch에서는 incorrectInput 에러만 잡는다. catch 안에 문장이 수행이 된다면 이제는 예외 상황이 아니기 때문에 catch 다음 문장으로 넘어갈 때는 정상 상황으로 넘어가게 된다. "이제부터는 정상 상황입니다^^" 한 번잡아주면 그 다음부터 정상 플로우로 복귀하게 된다 문제의 원인을 구분해서 추가적인 정보를 주기 위해서 클래스를 만드는 것이다. 부가적인 정보를 더 보낼 수 있긴함. 근데 클래스를 배우지 않았기 때문에 이거에 대한 설명은 하지 않았다. 클래스를 통해서, 상속을 통해서 예외처리를 좀 더 구체적으로 할 수는 있다.<br>

❓ 만약 input이 음수로 인한 에러가 뜬다면 product : exit -> solution : exit -> main 에서 catch 로 넘어가는거? ooo 만약에 solution에 incorrectInput 처리가 없다면 질문과 같은 플로우로 진행되게 된다. <br>

incorrectInput에 대한 catch를 solution과 main으로 둘 다 했을 때 위에서 먼저 잡는 순간 이미 정상 상황으로 돌아간 것이다. **_throw는 한번 잡히면 거기서 소멸된다._** 잡을 때 자기의 타입이 정해져있다. catch가 잡을 수 있는 애가 정해져 있다. 바람직하지 않지만 자주 쓰는 방법이 있다. 뭐든 잡겠어!!!!!!!!! 그 문법이 있다.
catch(...) {}; -> 이거임. 이걸 즐겨쓰는거는 권장되지 않아. 원인을 모르게되니까 최악의 경우를 막기 위해서 일단 잡는 것이지 뭐가 날라온지를 몰라서 그 상황에 맞는 적절한 조치를 할 수 없다. 그래서 일반적으로 권장되지는 않는다. <br>

지금까지

1. throw는 무엇인가
2. 클래스로 예외를 구별하는 의미
3. catch는 어느 영역을 감쌓야되는지
4. catch에 의해서 잡히지 않으면 어떻게 동작하는지, 잡히면 어떻게 동작하는지 <br>

에 대해서 배웠다. <br>

<br>

C와 C++의 차이 <br>

C는 예외 처리와 유사하게 구현은 가능하지만 구현법이 정상 플로우를 따라가게 되어있다. 정상 플롱를 따라간다는 말은 C++처럼 throw하면 중간에 함수를 종료시키는 return, exit이 필요하지 않은 것이아니라 반대로 return과 exit을 통해서 예외를 처리한다는 말이다. 즉, C의 경우는 리턴값을 판단하고 그런 다음 그 리턴값이 에러라면 이렇게 처리하고,, 이렇게 해야되는데 단점은 코드를 읽는 사람이 정상적인 플로우인지 예외에 대한 처리를 위한 플로우인지를 확인하기가 힘들다. C++처럼 가독성이 좋도록 만드는 코드가 예쁜 코드다. <br>

> throw = 문제, try = 의심 구간, Catch = 문제 해결/처리
